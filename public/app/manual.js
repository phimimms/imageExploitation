define(['ractive', 'rv!manual/manual'],
    function(Ractive, template) {
        /**
         * The source image element
         * @type {Element}
         */
        var img = null;

        /**
         * The default values for filter inputs
         * @type {Object}
         */
        var FILTER_DEFAULTS = {
            BRIGHTNESS: 1,
            CONTRAST: 1,
            GRAYSCALE: 0,
            HUE: 0,
            INVERT: 0,
            SATURATE: 1,
            SEPIA: 0
        };

        /**
         * Converts rgb color to hsl.
         * @param  {Integer} r The red value: [0, 1]
         * @param  {Integer} g The green value: [0, 1]
         * @param  {Integer} b The blue value: [0, 1]
         * @return {Object} Contains corresponding the hue, saturation, and lightness
         */
        var rgb2hsl = function(r, g, b) {
            var min = Math.min(r, g, b),
                max = Math.max(r, g, b);

            var h,
                s,
                l = (max + min) / 2;

            if (max === min) {
                h = 0;
                s = 0;
            } else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }

                h /= 6;
            }

            return {
                h: h,
                s: s,
                l: l
            };
        };

        /**
         * Converts hsl color to rgb.
         * @param  {Object} hsl Contains the hsl values
         * @return {Object} Contains the rgb values
         */
        var hsl2rgb = function(hsl) {
            if (!hsl.s) {
                var grey = Math.floor(hsl.l * 255);
                return {
                    r: grey,
                    g: grey,
                    b: grey
                };
            }

            var a = hsl.l < 0.5 ? hsl.l * (1 + hsl.s) : hsl.l + hsl.s - (hsl.l * hsl.s);
            var b = (2 * hsl.l) - a;

            return {
                r: hue2color(hsl.h + (1 / 3), a, b),
                g: hue2color(hsl.h - (1 / 3), a, b),
                b: hue2color(hsl.h, a, b)
            };
        };

        /**
         * Converts a hue to a color.
         * @param  {Number} hue The hue: [0, 1]
         * @param  {Number} a
         * @param  {Number} b
         * @return {Integer} The representative color: [0, 255]
         */
        var hue2color = function(hue, a, b) {
            if (hue < 0) {
                hue += 1;
            }
            if (hue > 1) {
                hue -= 1;
            }

            var color;
            if (hue < 1 / 6) {
                color = b + (a - b) * 6 * hue;
            } else if (hue < 1 / 2) {
                color = a;
            } else if (hue < 2 / 3) {
                color = b + (a - b) * ((2 / 3) - hue) * 6;
            } else {
                color = b;
            }

            return Math.floor(color * 255);
        };

        /**
         * Given an amount, returns a contrast transform matrix
         * @param  {Number} amount The amount of contrast to apply
         * @return {Array}
         */
        var getContrastMatrix = function(amount) {
            var matrix = [];

            for (var i = 0; i < 20; i++) {
                matrix[i] = 0;
            }

            matrix[0] = matrix[6] = matrix[12] = amount;
            matrix[4] = matrix[9] = matrix[14] = (-0.5 * amount + 0.5) * 255;
            matrix[18] = 1;

            return matrix;
        };


        /**
         * Given an amount, returns a grayscale transform matrix
         * @param  {Number} amount The amount of grayscale to apply [0 - 1]
         * @return {Array}
         */
        var getGrayscaleMatrix = function(amount) {
            amount = 1 - amount;
            var matrix = [];

            matrix[0] = 0.2126 + 0.7874 * amount;
            matrix[1] = 0.7152 - 0.7152 * amount;
            matrix[2] = 1 - (matrix[0] + matrix[1]);
            matrix[3] = matrix[4] = 0;

            matrix[5] = 0.2126 - 0.2126 * amount;
            matrix[6] = 0.7152 + 0.2848 * amount;
            matrix[7] = 1 - (matrix[5] + matrix[6]);
            matrix[8] = matrix[9] = 0;

            matrix[10] = 0.2126 - 0.2126 * amount;
            matrix[11] = 0.7152 - 0.7152 * amount;
            matrix[12] = 1 - (matrix[10] + matrix[11]);
            matrix[13] = matrix[14] = 0;

            matrix[15] = matrix[16] = matrix[17] = matrix[19] = 0;
            matrix[18] = 1;

            return matrix;
        };

        /**
         * Given an amount, returns a hue rotation transform matrix
         * @param  {Number} amount The amount of hue rotation to apply
         * @return {Array}
         */
        var getHueRotationMatrix = function(amount) {
            var matrix = [];
            var pi = 3.1415926535897932384626433832795;
            var cos_hue = Math.cos(amount * pi / 180);
            var sin_hue = Math.sin(amount * pi / 180);

            matrix[0] = 0.213 + cos_hue * 0.787 - sin_hue * 0.213;
            matrix[1] = 0.715 - cos_hue * 0.715 - sin_hue * 0.715;
            matrix[2] = 0.072 - cos_hue * 0.072 + sin_hue * 0.928;
            matrix[3] = matrix[4] = 0;

            matrix[5] = 0.213 - cos_hue * 0.213 + sin_hue * 0.143;
            matrix[6] = 0.715 + cos_hue * 0.285 + sin_hue * 0.140;
            matrix[7] = 0.072 - cos_hue * 0.072 - sin_hue * 0.283;
            matrix[8] = matrix[9] = 0;

            matrix[10] = 0.213 - cos_hue * 0.213 - sin_hue * 0.787;
            matrix[11] = 0.715 - cos_hue * 0.715 + sin_hue * 0.715;
            matrix[12] = 0.072 + cos_hue * 0.928 + sin_hue * 0.072;
            matrix[13] = matrix[14] = 0;

            matrix[15] = matrix[16] = matrix[17] = 0;
            matrix[18] = 1;
            matrix[19] = 0;

            return matrix;
        };

        /**
         * Given an amount, returns a saturate transform matrix
         * @param  {Number} amount The amount of saturation to apply
         * @return {Array}
         */
        var getSaturateMatrix = function(amount) {
            var matrix = [];

            matrix[0] = 0.213 + 0.787 * amount;
            matrix[1] = 0.715 - 0.715 * amount;
            matrix[2] = 1 - (matrix[0] + matrix[1]);
            matrix[3] = matrix[4] = 0;

            matrix[5] = 0.213 - 0.213 * amount;
            matrix[6] = 0.715 + 0.285 * amount;
            matrix[7] = 1 - (matrix[5] + matrix[6]);
            matrix[8] = matrix[9] = 0;

            matrix[10] = 0.213 - 0.213 * amount;
            matrix[11] = 0.715 - 0.715 * amount;
            matrix[12] = 1 - (matrix[10] + matrix[11]);
            matrix[13] = matrix[14] = 0;

            matrix[15] = matrix[16] = matrix[17] = matrix[19] = 0;
            matrix[18] = 1;

            return matrix;
        };

        /**
         * Given an amount, returns a sepia transform matrix
         * @param  {Number} amount The amount of sepia to apply [0 - 1]
         * @return {Array}
         */
        getSepiaMatrix = function(amount) {
            amount = 1 - amount;
            var matrix = [];

            matrix[0] = 0.393 + 0.607 * amount;
            matrix[1] = 0.769 - 0.769 * amount;
            matrix[2] = 0.189 - 0.189 * amount;
            matrix[3] = matrix[4] = 0;

            matrix[5] = 0.349 - 0.349 * amount;
            matrix[6] = 0.686 + 0.314 * amount;
            matrix[7] = 0.168 - 0.168 * amount;
            matrix[8] = matrix[9] = 0;

            matrix[10] = 0.272 - 0.272 * amount;
            matrix[11] = 0.534 - 0.534 * amount;
            matrix[12] = 0.131 + 0.869 * amount;
            matrix[13] = matrix[14] = 0;

            matrix[15] = matrix[16] = matrix[17] = matrix[19] = 0;
            matrix[18] = 1;

            return matrix;
        };

        /**
         * Mulitplies each pixel by the given matrix to directly apply the transform
         * @param  {Array.<Integer>} pixels Array of pixel data, each 4 corresponding to R, G, B, A channels
         * @param  {Array.<Number>} Size 20 array corresponding to a 4 x 5 matrix in row-major order. Will be multiplied
         *                          by each pixel as a vector with an extra 1 appended to the end. The values in the 5th
         *                          column are used for translation.
         */
        var applyMatrixTransform = function(pixels, matrix) {
            for (var i = 0, len = pixels.length; i < len; i += 4) {
                var rgbaIn = [pixels[i], pixels[i + 1], pixels[i + 2], pixels[i + 3], 1];

                for (var m = 0; m < 4; m++) {
                    var val = 0;
                    for (var n = 0; n < 5; n++) {
                        val += matrix[5 * m + n] * rgbaIn[n];
                    }
                    pixels[i + m] = val;
                }
            }
        };

        /**
         * Applies the brightness filter.
         * @param  {Array.<Integer>} pixels The pixels of the canvas
         * @param  {Number} value The brightness multiplier
         */
        var adjustBrightness = function(pixels, value) {
            for (var i = 0, n = pixels.length; i < n; i += 4) {
                pixels[i] = Math.max(0, Math.min(255, pixels[i] * value));
                pixels[i + 1] = Math.max(0, Math.min(255, pixels[i + 1] * value));
                pixels[i + 2] = Math.max(0, Math.min(255, pixels[i + 2] * value));
            }
        };

        /**
         * Applies the contrast filter.
         * @param  {Array.<Integer>} pixels The pixels of the canvas
         * @param  {Number} value  The contrast multiplier
         */
        var adjustContrast = function(pixels, value) {
            applyMatrixTransform(pixels, getContrastMatrix(value));

            // Old implementation
            // var factor = (259 * (value + 255)) / (255 * (259 - value));

            // for (var i = 0, n = pixels.length; i < n; i += 4) {
            //     pixels[i] = factor * (pixels[i] - 128) + 128;
            //     pixels[i + 1] = factor * (pixels[i + 1] - 128) + 128;
            //     pixels[i + 2] = factor * (pixels[i + 2] - 128) + 128;
            // }
        };

        /**
         * Applies the hue filter.
         * @param  {Array.<Integer>} pixels The pixels of the canvas
         * @param  {Number} value  The hue multiplier
         */
        var adjustHue = function(pixels, value) {
            applyMatrixTransform(pixels, getHueRotationMatrix(value));

            // Old implementation
            // for (var i = 0, n = pixels.length; i < n; i += 4) {
                
            //     var red = pixels[i] / 255,
            //         green = pixels[i + 1] / 255,
            //         blue = pixels[i + 2] / 255;

            //     var hsl = rgb2hsl(red, blue, green);
            //     hsl.h += value;

            //     if (hsl.h > 1) {
            //         hsl.h -= 1;
            //     }

            //     var rgb = hsl2rgb(hsl);

            //     pixels[i] = rgb.r;
            //     pixels[i + 1] = rgb.g;
            //     pixels[i + 2] = rgb.b;
            // }
        };

        /**
         * Applies the grayscale filter.
         * @param  {Array.<Integer>} pixels The pixels of the canvas
         * @param  {Number} value  The slider value
         */
        var adjustGrayscale = function(pixels, value) {
            applyMatrixTransform(pixels, getGrayscaleMatrix(value));

            // Old implementation:
            // for (var i = 0, n = pixels.length; i < n; i += 4) {
            //     var gray = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
            //     pixels[i] = gray;
            //     pixels[i + 1] = gray;
            //     pixels[i + 2] = gray;
            // }
        };

        /**
         * Applies the invert filter.
         * @param  {Array.<Integer>} pixels The pixels of the canvas
         */
        var adjustInvert = function(pixels) {
            for (var i = 0, n = pixels.length; i < n; i += 4) {
                pixels[i] = 255 - pixels[i];
                pixels[i + 1] = 255 - pixels[i + 1];
                pixels[i + 2] = 255 - pixels[i + 2];
            }
        };

        /**
         * Applies the saturate filter.
         * @param  {Array.<Integer>} pixels The pixels of the canvas
         * @param  {Number} value The saturate multiplier
         */
        var adjustSaturate = function(pixels, value) {
            applyMatrixTransform(pixels, getSaturateMatrix(value));

            // Old implementation
            // Luminance constants
            // var luR = 0.3086,
            //     luG = 0.6094,
            //     luB = 0.0820;

            // var c = 1 - value,
            //     az = c * luR + value,
            //     bz = c * luG,
            //     cz = c * luB,
            //     dz = c * luR,
            //     ez = c * luG + value,
            //     fz = c * luB,
            //     gz = c * luR,
            //     hz = c * luG,
            //     iz = c * luB + value;

            // for (var i = 0, n = pixels.length; i < n; i += 4) {
            //     var red = pixels[i],
            //         green = pixels[i + 1],
            //         blue = pixels[i + 2];

            //     pixels[i] = (az * red) + (bz * green) + (cz * blue);
            //     pixels[i + 1] = (dz * red) + (ez * green) + (fz * blue);
            //     pixels[i + 2] = (gz * red) + (hz * green) + (iz * blue);
            // }
        };

        /**
         * Applies the sepia filter.
         * @param  {Array.<Integer>} pixels The pixels of the canvas
         * @param  {Number} value  The slide value
         */
        var adjustSepia = function(pixels, value) {
            applyMatrixTransform(pixels, getSepiaMatrix(value));
        };

        /**
         * Creates a new canvas element with the source image.
         * @return {Element} The new canvas element
         */
        var getInitialCanvas = function() {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');

            // Resizes the canvas for the DOM
            canvas.width = img.width > 620 ? 620 : img.width;
            canvas.height = img.width > 620 ? img.height / img.width * 620 : img.width;

            context.drawImage(img, 0, 0, canvas.width, canvas.height);

            return canvas;
        };

        return {
            /**
             * The data bound to the view.
             * Represents the values of the filters applied to the image.
             * @type {Object}
             */
            data: {
                brightness: FILTER_DEFAULTS.BRIGHTNESS,
                contrast: FILTER_DEFAULTS.CONTRAST,
                grayscale: FILTER_DEFAULTS.GRAYSCALE,
                hue: FILTER_DEFAULTS.HUE,
                invert: FILTER_DEFAULTS.INVERT,
                saturate: FILTER_DEFAULTS.SATURATE,
                sepia: FILTER_DEFAULTS.SEPIA
            },

            /**
             * Initializes the Ractive instance and renders it to the DOM.
             * @param  {Element} parentElement The parent element
             */
            initialize: function(parentElement) {
                this._ractive = new Ractive({
                    append: true,
                    data: this.data,
                    el: parentElement,
                    template: template
                });

                this._canvas = this._ractive.find('#manualCanvas');
                this._context = this._canvas.getContext('2d');

                img = new Image();
                img.onload = function() {
                    var c = getInitialCanvas();
                    this._canvas.width = c.width;
                    this._canvas.height = c.height;
                    this._context.drawImage(img, 0, 0, c.width, c.height);
                }.bind(this);
                img.src = 'app/testImage.jpg';

                this._ractive.observe('brightness', this.filterCanvas.bind(this));
                this._ractive.observe('contrast', this.filterCanvas.bind(this));
                this._ractive.observe('grayscale', this.filterCanvas.bind(this));
                this._ractive.observe('hue', this.filterCanvas.bind(this));
                this._ractive.observe('invert', this.filterCanvas.bind(this));
                this._ractive.observe('saturate', this.filterCanvas.bind(this));
                this._ractive.observe('sepia', this.filterCanvas.bind(this));

                this._resultImage = this._ractive.find('#manualResult');

                this._ractive.on({
                    captureImage: this.captureImage.bind(this),
                    defaults: this.setToDefault.bind(this)
                });
            },

            /**
             * Applies the new filter state to the preview canvas on the DOM.
             */
            filterCanvas: function() {
                if (!img || !img.width) {
                    // img has not loaded
                    return;
                }

                var canvas = getInitialCanvas();
                var context = canvas.getContext('2d');

                var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                this.applyFilters(imageData.data);

                this._context.putImageData(imageData, 0, 0);
            },

            /**
             * Mutates the pixels of a canvas as specified by its filter state.
             * @param  {Array.<Integer>} pixels The pixels of the canvas
             */
            applyFilters: function(pixels) {
                if (this.data.brightness !== FILTER_DEFAULTS.BRIGHTNESS) {
                    adjustBrightness(pixels, this.data.brightness);
                }

                if (this.data.contrast !== FILTER_DEFAULTS.CONTRAST) {
                    adjustContrast(pixels, this.data.contrast);
                }

                if (this.data.grayscale !== FILTER_DEFAULTS.GRAYSCALE) {
                    adjustGrayscale(pixels, this.data.grayscale);
                }

                if (this.data.hue !== FILTER_DEFAULTS.HUE) {
                    adjustHue(pixels, this.data.hue);
                }

                if (this.data.invert) {
                    adjustInvert(pixels);
                }

                if (this.data.saturate !== FILTER_DEFAULTS.SATURATE) {
                    adjustSaturate(pixels, this.data.saturate);
                }

                if (this.data.sepia !== FILTER_DEFAULTS.SEPIA) {
                    adjustSepia(pixels, this.data.sepia);
                }
            },

            /**
             * Applies the filters in the source image's original resolution.
             */
            captureImage: function() {
                var canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;

                var context = canvas.getContext('2d');
                context.drawImage(img, 0, 0, img.width, img.height);

                var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                this.applyFilters(imageData.data);

                context.putImageData(imageData, 0, 0);
                var dataURL = canvas.toDataURL('image/png');

                this._resultImage.setAttribute('src', dataURL);
            },

            /**
             * Resets the filter state.
             */
            setToDefault: function() {
                this._ractive.set('brightness', FILTER_DEFAULTS.BRIGHTNESS);
                this._ractive.set('contrast', FILTER_DEFAULTS.CONTRAST);
                this._ractive.set('grayscale', FILTER_DEFAULTS.GRAYSCALE);
                this._ractive.set('hue', FILTER_DEFAULTS.HUE);
                this._ractive.set('invert', FILTER_DEFAULTS.INVERT);
                this._ractive.set('saturate', FILTER_DEFAULTS.SATURATE);
                this._ractive.set('sepia', FILTER_DEFAULTS.SEPIA);
            }
        };
    }
);
